/**
 * BossFactory.js - 5种Boss类型工厂
 * charger / guardian / summoner / laser / phantom
 * 每种Boss有独立的 update() 和 getRenderData()
 */
const Config = require('./Config');
const BrickFactory = require('./BrickFactory');

// ===== Boss 基类 =====
class BossBase {
  constructor(type, baseHp, hpMult, cycle, gameAreaWidth) {
    this.type = type;
    this.width = Config.BOSS_WIDTH;
    this.height = Config.BOSS_HEIGHT;
    this.x = (gameAreaWidth - this.width) / 2;
    this.y = Config.SAFE_TOP + 20;
    this.gameAreaWidth = gameAreaWidth;
    this.alive = true;
    this.direction = 1;
    this.speed = Config.BOSS_SPEED;

    this.maxHp = Math.floor(baseHp * hpMult);
    this.hp = this.maxHp;
    this.cycle = cycle;
    this.hpMult = hpMult;

    this.actionTimer = 0;
    this.state = 'idle';
    this.stateTimer = 0;
    this.flashTimer = 0;

    // Boss击杀标记
    this.phase = 0;
    this.phaseChangeFlash = 0;

    // 弱点倍率（某些状态受额外伤害）
    this.damageMult = 1.0;

    // 子类可覆盖
    this._spawnedBricks = [];
    this._fireTrails = [];
    this._laserData = null;

    // 持续下压
    this.descendSpeed = 0.08 + cycle * 0.01;

    // ===== 部件系统 =====
    // parts: 相对于(this.x, this.y)的偏移部件
    // 每个part: { ox, oy, w, h, color(可选) }
    this.parts = [{ ox: 0, oy: 0, w: this.width, h: this.height }];
  }

  // 初始化部件形状（子类调用）
  _initParts(partDefs) {
    this.parts = partDefs;
    // 计算包围盒用于左右移动限制
    var minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
    for (var i = 0; i < partDefs.length; i++) {
      var p = partDefs[i];
      if (p.ox < minX) minX = p.ox;
      if (p.ox + p.w > maxX) maxX = p.ox + p.w;
      if (p.oy < minY) minY = p.oy;
      if (p.oy + p.h > maxY) maxY = p.oy + p.h;
    }
    this.width = maxX - minX;
    this.height = maxY - minY;
    this._partsOffsetX = minX;
    this._partsOffsetY = minY;
    // 居中
    this.x = (this.gameAreaWidth - this.width) / 2 - this._partsOffsetX;
  }

  hit(damage) {
    var actual = damage * this.damageMult;
    this.hp -= actual;
    this.flashTimer = 100;
    if (this.hp <= 0) {
      this.hp = 0;
      this.alive = false;
      return true;
    }
    return false;
  }

  getCenterX() { return this.x + this.width / 2; }
  getCenterY() { return this.y + this.height / 2; }
  getHpRatio() { return this.hp / this.maxHp; }

  getPhaseColor() { return Config.NEON_CYAN; }

  collectSpawnedBricks() {
    var bricks = this._spawnedBricks;
    this._spawnedBricks = [];
    return bricks;
  }

  // 检测点是否在Boss任意部件内
  hitTestPoint(px, py) {
    for (var i = 0; i < this.parts.length; i++) {
      var p = this.parts[i];
      var rx = this.x + p.ox, ry = this.y + p.oy;
      if (px >= rx && px <= rx + p.w && py >= ry && py <= ry + p.h) return true;
    }
    return false;
  }

  // 检测AABB是否与Boss任意部件碰撞
  hitTestRect(rx, ry, rw, rh) {
    for (var i = 0; i < this.parts.length; i++) {
      var p = this.parts[i];
      var px = this.x + p.ox, py = this.y + p.oy;
      if (rx < px + p.w && rx + rw > px && ry < py + p.h && ry + rh > py) return true;
    }
    return false;
  }

  _moveLeftRight(dt, speedMult) {
    this.x += this.speed * (speedMult || 1) * this.direction * dt;
    var minOx = this._partsOffsetX || 0;
    if (this.x + minOx <= 0) { this.x = -minOx; this.direction = 1; }
    var maxRight = 0;
    for (var i = 0; i < this.parts.length; i++) {
      var r = this.parts[i].ox + this.parts[i].w;
      if (r > maxRight) maxRight = r;
    }
    if (this.x + maxRight >= this.gameAreaWidth) {
      this.x = this.gameAreaWidth - maxRight;
      this.direction = -1;
    }
  }

  _descend(dt) {
    this.y += this.descendSpeed * dt;
  }

  isPastDangerLine() {
    var dangerY = Config.SCREEN_HEIGHT * Config.BRICK_DANGER_Y;
    for (var i = 0; i < this.parts.length; i++) {
      if (this.y + this.parts[i].oy + this.parts[i].h >= dangerY) return true;
    }
    return false;
  }

  update(dtMs) {
    var dt = dtMs / 16.67;
    if (this.flashTimer > 0) this.flashTimer -= dtMs;
    if (this.phaseChangeFlash > 0) this.phaseChangeFlash -= dtMs;
  }

  getRenderData() {
    return {
      type: this.type,
      state: this.state,
      stateTimer: this.stateTimer,
      cycle: this.cycle,
      parts: this.parts,
    };
  }
}

// ===== Charger（冲锋者）=====
class ChargerBoss extends BossBase {
  constructor(hpMult, cycle, gameAreaWidth) {
    super('charger', 4800, hpMult, cycle, gameAreaWidth);
    this.chargeInterval = cycle >= 3 ? 5000 : 6000;
    this.chargeTime = cycle >= 3 ? 1000 : 1500;
    this.chargeDist = 120;
    this.originalY = this.y;
    this.chargeTargetY = this.y + this.chargeDist;
    this.stunTimer = 0;
    this.returnSpeed = 2;
    this._fireTrails = [];

    // 冲锋者形状：倒三角箭头（冲击感）
    //    ████████████████
    //      ████████████
    //        ████████
    //          ████
    var bw = 30, bh = 20;
    this._initParts([
      { ox: 0,      oy: 0,       w: bw * 7, h: bh },      // 顶部长条
      { ox: bw,     oy: bh,      w: bw * 5, h: bh },      // 第二层
      { ox: bw * 2, oy: bh * 2,  w: bw * 3, h: bh },      // 第三层
      { ox: bw * 3, oy: bh * 3,  w: bw,     h: bh },      // 尖端
    ]);
  }

  getPhaseColor() { return '#FF3333'; }

  update(dtMs) {
    var dt = dtMs / 16.67;
    if (this.flashTimer > 0) this.flashTimer -= dtMs;

    // 持续下压（作用在基准线上）
    this.originalY += this.descendSpeed * dt;

    switch (this.state) {
      case 'idle':
        this.damageMult = 1.0;
        this.y = this.originalY; // 跟随基准线
        this._moveLeftRight(dt, 1);
        this.actionTimer += dtMs;
        if (this.actionTimer >= this.chargeInterval) {
          this.actionTimer = 0;
          this.state = 'charging';
          this.stateTimer = 0;
        }
        break;

      case 'charging':
        // 闪烁警告阶段
        this.damageMult = 1.0;
        this.y = this.originalY;
        this.stateTimer += dtMs;
        if (this.stateTimer >= this.chargeTime) {
          this.state = 'rushing';
          this.stateTimer = 0;
          this.chargeTargetY = this.y + this.chargeDist;
        }
        break;

      case 'rushing':
        // 加速下冲
        this.damageMult = 0.5;
        this.y += 6 * dt;
        this.stateTimer += dtMs;
        if (this.y >= this.chargeTargetY || this.stateTimer > 1500) {
          if (this.cycle >= 1) {
            this._fireTrails.push({
              x: this.x, y: this.y, width: this.width,
              timer: 2000,
            });
          }
          this.state = 'stunned';
          this.stateTimer = 0;
          this.stunTimer = 1000;
        }
        break;

      case 'stunned':
        this.damageMult = 2.0;
        this.stateTimer += dtMs;
        if (this.stateTimer >= this.stunTimer) {
          this.state = 'returning';
          this.stateTimer = 0;
        }
        break;

      case 'returning':
        this.damageMult = 1.0;
        this.y -= this.returnSpeed * dt;
        if (this.y <= this.originalY) {
          this.y = this.originalY;
          this.state = 'idle';
          this.actionTimer = 0;
        }
        break;
    }

    // 更新火焰地带
    for (var i = this._fireTrails.length - 1; i >= 0; i--) {
      this._fireTrails[i].timer -= dtMs;
      if (this._fireTrails[i].timer <= 0) this._fireTrails.splice(i, 1);
    }
  }

  getRenderData() {
    return {
      type: 'charger',
      state: this.state,
      stateTimer: this.stateTimer,
      chargeTime: this.chargeTime,
      cycle: this.cycle,
      fireTrails: this._fireTrails,
    };
  }
}

// ===== Guardian（护盾卫士）=====
class GuardianBoss extends BossBase {
  constructor(hpMult, cycle, gameAreaWidth) {
    super('guardian', 5600, hpMult, cycle, gameAreaWidth);
    this.shieldCount = cycle >= 1 ? 3 : 2;
    this.shieldMaxHp = Math.floor(80 * hpMult);
    this.shields = [];
    this.shieldAngle = 0;
    this.shieldSpeed = 0.02;
    this.shieldRegenTime = cycle >= 3 ? 5000 : 8000;
    this.shieldDownTimer = 0;
    this.allShieldsDown = false;
    this.windowTimer = 0;

    // 护盾卫士形状：堡垒（方正厚实+两侧炮塔）
    //  ██        ██
    //  ██████████████
    //  ██████████████
    //    ██████████
    var bw = 25, bh = 20;
    this._initParts([
      { ox: 0,        oy: 0,       w: bw * 2, h: bh },      // 左炮塔
      { ox: bw * 6,   oy: 0,       w: bw * 2, h: bh },      // 右炮塔
      { ox: 0,        oy: bh,      w: bw * 8, h: bh },      // 主体上层
      { ox: 0,        oy: bh * 2,  w: bw * 8, h: bh },      // 主体下层
      { ox: bw,       oy: bh * 3,  w: bw * 6, h: bh },      // 底部
    ]);

    this._initShields();
  }

  _initShields() {
    this.shields = [];
    for (var i = 0; i < this.shieldCount; i++) {
      this.shields.push({
        hp: this.shieldMaxHp,
        maxHp: this.shieldMaxHp,
        alive: true,
        angle: (Math.PI * 2 / this.shieldCount) * i,
      });
    }
    this.allShieldsDown = false;
    this.windowTimer = 0;
    this.shieldDownTimer = 0;
  }

  getPhaseColor() { return '#4488FF'; }

  /**
   * 检查子弹是否碰到护盾
   * 返回 true 表示被护盾挡住
   */
  hitShield(bulletX, bulletY, bulletRadius) {
    if (this.allShieldsDown) return false;
    var cx = this.getCenterX();
    var cy = this.getCenterY();
    var shieldRadius = 50;
    var shieldArc = Math.PI * 0.5; // 每块护盾覆盖90度弧

    for (var i = 0; i < this.shields.length; i++) {
      var s = this.shields[i];
      if (!s.alive) continue;
      // 护盾位置
      var sx = cx + Math.cos(s.angle + this.shieldAngle) * shieldRadius;
      var sy = cy + Math.sin(s.angle + this.shieldAngle) * shieldRadius;
      var dist = Math.sqrt((bulletX - sx) * (bulletX - sx) + (bulletY - sy) * (bulletY - sy));
      if (dist < 20 + bulletRadius) {
        s.hp--;
        if (s.hp <= 0) {
          s.alive = false;
          // 检查是否全碎
          var anyAlive = false;
          for (var j = 0; j < this.shields.length; j++) {
            if (this.shields[j].alive) { anyAlive = true; break; }
          }
          if (!anyAlive) {
            this.allShieldsDown = true;
            this.windowTimer = 5000;
            this.shieldDownTimer = 0;
          }
        }
        return true;
      }
    }
    return false;
  }

  update(dtMs) {
    var dt = dtMs / 16.67;
    if (this.flashTimer > 0) this.flashTimer -= dtMs;

    this._descend(dt);
    this._moveLeftRight(dt, 0.8);
    this.shieldAngle += this.shieldSpeed * dt;

    if (this.allShieldsDown) {
      this.damageMult = 1.5; // 窗口期加伤
      this.windowTimer -= dtMs;
      if (this.windowTimer <= 0) {
        // 窗口期过了开始再生计时
        this.shieldDownTimer += dtMs;
        this.damageMult = 1.0;
        if (this.shieldDownTimer >= this.shieldRegenTime) {
          this._initShields();
        }
      }
    } else {
      this.damageMult = 1.0;
    }
  }

  getRenderData() {
    return {
      type: 'guardian',
      state: this.allShieldsDown ? 'vulnerable' : 'shielded',
      shields: this.shields,
      shieldAngle: this.shieldAngle,
      cycle: this.cycle,
      windowTimer: this.windowTimer,
    };
  }
}

// ===== Summoner（召唤师）=====
class SummonerBoss extends BossBase {
  constructor(hpMult, cycle, gameAreaWidth) {
    super('summoner', 4000, hpMult, cycle, gameAreaWidth);
    this.summonInterval = cycle >= 1 ? 4000 : 5000;
    this.summonInvulnTime = 2000;
    this.invulnTimer = 0;

    // 召唤师形状：十字（魔法符号感）
    //      ████
    //  ████████████
    //      ████
    //      ████
    var bw = 30, bh = 22;
    this._initParts([
      { ox: bw * 2, oy: 0,       w: bw * 2, h: bh },      // 顶臂
      { ox: 0,      oy: bh,      w: bw * 6, h: bh },      // 横臂（宽）
      { ox: bw * 2, oy: bh * 2,  w: bw * 2, h: bh },      // 下臂1
      { ox: bw * 2, oy: bh * 3,  w: bw * 2, h: bh },      // 下臂2
    ]);
  }

  getPhaseColor() { return '#AA44FF'; }

  update(dtMs) {
    var dt = dtMs / 16.67;
    if (this.flashTimer > 0) this.flashTimer -= dtMs;

    this._descend(dt);

    switch (this.state) {
      case 'idle':
        this.damageMult = 1.0;
        this._moveLeftRight(dt, 0.6);
        this.actionTimer += dtMs;
        if (this.actionTimer >= this.summonInterval) {
          this.actionTimer = 0;
          this.state = 'summoning';
          this.stateTimer = 0;
          this.invulnTimer = this.summonInvulnTime;
          this.damageMult = 0;
          this._summonBricks();
        }
        break;

      case 'summoning':
        this.damageMult = 0;
        this.stateTimer += dtMs;
        this.invulnTimer -= dtMs;
        if (this.invulnTimer <= 0) {
          this.state = 'idle';
          this.damageMult = 1.0;
        }
        break;
    }
  }

  _summonBricks() {
    var y = this.y + this.height + 10;
    var phase = {
      types: ['normal'],
      timeCurve: [2.0, 3.0],
      spawnMult: 1.0,
    };
    if (this.cycle >= 2) {
      phase.types = ['normal', 'fast', 'shield'];
      phase.timeCurve = [3.0, 4.0];
    }
    var config = {
      baseHP: 1 + this.cycle * 0.5,
      chapterScale: this.hpMult,
      gapChance: 0.2,
    };

    var row = BrickFactory.generateRow(this.gameAreaWidth, y, phase, config);
    this._spawnedBricks = this._spawnedBricks.concat(row);

    // cycle>=3: 召唤两行
    if (this.cycle >= 3) {
      var y2 = y - Config.BRICK_HEIGHT - Config.BRICK_PADDING;
      var row2 = BrickFactory.generateRow(this.gameAreaWidth, y2, phase, config);
      this._spawnedBricks = this._spawnedBricks.concat(row2);
    }
  }

  getRenderData() {
    return {
      type: 'summoner',
      state: this.state,
      stateTimer: this.stateTimer,
      invulnTimer: this.invulnTimer,
      cycle: this.cycle,
    };
  }
}

// ===== LaserTurret（激光炮台）=====
class LaserTurretBoss extends BossBase {
  constructor(hpMult, cycle, gameAreaWidth) {
    super('laser', 6400, hpMult, cycle, gameAreaWidth);
    this.fireInterval = cycle >= 3 ? 6000 : 8000;
    this.chargeTime = 2000;
    this.laserDuration = 1500;
    this._laserData = null;

    // 激光炮台形状：T字（炮台+底座）
    //  ██████████████
    //  ██████████████
    //      ██████
    //      ██████
    //    ██████████
    var bw = 25, bh = 18;
    this._initParts([
      { ox: 0,      oy: 0,       w: bw * 8, h: bh },      // 炮管上
      { ox: 0,      oy: bh,      w: bw * 8, h: bh },      // 炮管下
      { ox: bw * 2, oy: bh * 2,  w: bw * 4, h: bh },      // 中轴上
      { ox: bw * 2, oy: bh * 3,  w: bw * 4, h: bh },      // 中轴下
      { ox: bw,     oy: bh * 4,  w: bw * 6, h: bh },      // 底座
    ]);
  }

  getPhaseColor() { return '#FFF050'; }

  update(dtMs) {
    var dt = dtMs / 16.67;
    if (this.flashTimer > 0) this.flashTimer -= dtMs;

    this._descend(dt);

    switch (this.state) {
      case 'idle':
        this.damageMult = 1.0;
        this._moveLeftRight(dt, 0.8);
        this.actionTimer += dtMs;
        if (this.actionTimer >= this.fireInterval) {
          this.actionTimer = 0;
          this.state = 'charging';
          this.stateTimer = 0;
        }
        break;

      case 'charging':
        this.damageMult = 3.0;
        this.stateTimer += dtMs;
        this._laserData = {
          charging: true,
          x: this.getCenterX(),
          progress: this.stateTimer / this.chargeTime,
        };
        if (this.stateTimer >= this.chargeTime) {
          this.state = 'firing';
          this.stateTimer = 0;
        }
        break;

      case 'firing':
        this.damageMult = 1.0;
        this.stateTimer += dtMs;
        var laserWidth = 30;
        // cycle>=2: 双炮管
        this._laserData = {
          charging: false,
          firing: true,
          x: this.getCenterX(),
          width: laserWidth,
          dual: this.cycle >= 2,
          dualOffsets: this.cycle >= 2 ? [-30, 30] : [0],
        };
        if (this.stateTimer >= this.laserDuration) {
          this.state = 'idle';
          this._laserData = null;
          // cycle>=1: 灼烧带
          if (this.cycle >= 1) {
            this._fireTrails.push({
              x: this.getCenterX() - laserWidth / 2,
              y: this.y + this.height,
              width: laserWidth,
              timer: 3000,
            });
          }
        }
        break;
    }

    // 更新灼烧带
    for (var i = this._fireTrails.length - 1; i >= 0; i--) {
      this._fireTrails[i].timer -= dtMs;
      if (this._fireTrails[i].timer <= 0) this._fireTrails.splice(i, 1);
    }
  }

  /** 检查子弹是否在激光范围内（范围内子弹被消除） */
  isInLaserZone(bulletX, bulletY) {
    if (!this._laserData || !this._laserData.firing) return false;
    var offsets = this._laserData.dualOffsets || [0];
    for (var i = 0; i < offsets.length; i++) {
      var lx = this._laserData.x + offsets[i];
      if (Math.abs(bulletX - lx) < this._laserData.width / 2) {
        return true;
      }
    }
    return false;
  }

  getRenderData() {
    return {
      type: 'laser',
      state: this.state,
      stateTimer: this.stateTimer,
      cycle: this.cycle,
      laserData: this._laserData,
      fireTrails: this._fireTrails,
    };
  }
}

// ===== Phantom（幽影刺客）=====
class PhantomBoss extends BossBase {
  constructor(hpMult, cycle, gameAreaWidth) {
    super('phantom', 4480, hpMult, cycle, gameAreaWidth);
    this.blinkInterval = cycle >= 3 ? 3000 : 4000;
    this.appearWindowTime = 1000; // 出现后1秒双倍伤害
    this.invisTimer = 0;
    this.appearTimer = 0;
    this.speed = Config.BOSS_SPEED * 1.5;
    this._afterImages = []; // 残影

    // 幽影刺客形状：菱形（灵活尖锐）
    var bw = 28, bh = 18;
    this._initParts([
      { ox: bw * 2, oy: 0,       w: bw * 2, h: bh },
      { ox: bw,     oy: bh,      w: bw * 4, h: bh },
      { ox: 0,      oy: bh * 2,  w: bw * 6, h: bh },
      { ox: bw,     oy: bh * 3,  w: bw * 4, h: bh },
      { ox: bw * 2, oy: bh * 4,  w: bw * 2, h: bh },
    ]);
  }

  getPhaseColor() { return '#DDDDDD'; }

  update(dtMs) {
    var dt = dtMs / 16.67;
    if (this.flashTimer > 0) this.flashTimer -= dtMs;

    this._descend(dt);

    switch (this.state) {
      case 'idle':
        this._moveLeftRight(dt, 1.2);
        this.appearTimer += dtMs;
        if (this.appearTimer < this.appearWindowTime) {
          this.damageMult = 2.0;
        } else {
          this.damageMult = 1.0;
        }
        this.actionTimer += dtMs;
        if (this.actionTimer >= this.blinkInterval) {
          this.actionTimer = 0;
          this.state = 'blinking';
          this.stateTimer = 0;
          this.invisTimer = 500;
          if (this.cycle >= 1) {
            this._afterImages.push({
              x: this.x, y: this.y, timer: 2000,
              width: this.width, height: this.height,
            });
          }
        }
        break;

      case 'blinking':
        this.damageMult = 0;
        this.stateTimer += dtMs;
        if (this.stateTimer >= this.invisTimer) {
          // 随机x，y保持当前下压高度附近浮动
          this.x = Math.random() * (this.gameAreaWidth - this.width);
          this.y = this.y + (Math.random() - 0.5) * 30;
          this.state = 'idle';
          this.appearTimer = 0;
          this.damageMult = 2.0;
          this._spawnAppearBricks();
        }
        break;
    }

    // 更新残影
    for (var i = this._afterImages.length - 1; i >= 0; i--) {
      this._afterImages[i].timer -= dtMs;
      if (this._afterImages[i].timer <= 0) this._afterImages.splice(i, 1);
    }
  }

  _spawnAppearBricks() {
    var y = this.y + this.height + 5;
    var phase = {
      types: this.cycle >= 2 ? ['split'] : ['fast'],
      timeCurve: [1.5, 2.0],
      spawnMult: 1.0,
    };
    var config = {
      baseHP: 1,
      chapterScale: this.hpMult * 0.5,
      gapChance: 0.3,
    };
    var row = BrickFactory.generateRow(this.gameAreaWidth, y, phase, config);
    this._spawnedBricks = this._spawnedBricks.concat(row);
  }

  getRenderData() {
    return {
      type: 'phantom',
      state: this.state,
      stateTimer: this.stateTimer,
      cycle: this.cycle,
      afterImages: this._afterImages,
      appearTimer: this.appearTimer,
      appearWindowTime: this.appearWindowTime,
    };
  }
}

// ===== 工厂函数 =====

function createBoss(type, chapter, gameAreaWidth) {
  var cycle = Math.floor((chapter - 1) / 5);
  var hpMult = 1.0 + (chapter - 1) * 0.12;
  switch (type) {
    case 'charger':  return new ChargerBoss(hpMult, cycle, gameAreaWidth);
    case 'guardian':  return new GuardianBoss(hpMult, cycle, gameAreaWidth);
    case 'summoner':  return new SummonerBoss(hpMult, cycle, gameAreaWidth);
    case 'laser':     return new LaserTurretBoss(hpMult, cycle, gameAreaWidth);
    case 'phantom':   return new PhantomBoss(hpMult, cycle, gameAreaWidth);
    default:          return new ChargerBoss(hpMult, cycle, gameAreaWidth);
  }
}

module.exports = {
  createBoss: createBoss,
  BossBase: BossBase,
  ChargerBoss: ChargerBoss,
  GuardianBoss: GuardianBoss,
  SummonerBoss: SummonerBoss,
  LaserTurretBoss: LaserTurretBoss,
  PhantomBoss: PhantomBoss,
};
